# Фрейм знаний
https://ru.wikipedia.org/wiki/Фрейм_(инженерия_знаний)

![[bib/kb#minsky]]

[[Марвин Минский]] в своей статье [minsky] предложил термин **фрейм** (frame) для модели представления человеческих знаний, и структуру данных для их описания, которая очень напоминает объекты в современном ООП.

Так как нас в дальнейшем будет интересовать [[метапрограммирование]], в частности генерация и *трансформация исходного кода* программ, оригинальной модели фрейма будет недостаточно -- Минский не предусмотрел **упорядочивания ссылок** на другие фреймы.

Например, если мы хотим представить выражение $1.2/3$ в виде фрейма, мы можем выделить в качестве корневого фрейма оператор деления `<op:/>`, который ссылается на фреймы чисел `<float:1.2>` и `<int:3>`, но тут нам важны не имена операндов, а их порядок.

Обычно в [[разработке компиляторов|разработке компиляторов]] для описания подобных выражений используется [[атрибутная грамматика]], и соответствующая специализированная *упорядоченная структура данных* -- **направленный граф** или дерево для хранения атрибутов и списка ссылок на вложенные выражения.

Чтобы объединить оба подхода, и интегрировать их с современными языками программирования (для простоты используем [[Python]]), библиотеками и средами исполнения, за основу можно взять следующую базовую структуру данных:

```py
## базовый фрейм
class Object:
    def __init__(self, V):

        ## тег типа/класса: необходим для библиотеки PLY
        self.type = self.__class__.__name__.lower()

        ## скаляр: имя объекта, значения числа/строки
        self.value = V

        ## слоты: ассоциативный массив имя -> фрейм, атрибуты
        ## одновременно является env/namespace и Форт-словарём
        self.slot = {}

        ## подвыраженя AST = список/вектор = очередь
        self.nest = []
```

В результате получаем универсальную структуру данных, которая может представлять любые знания, **данные = программы** ([[гомоиконичность]]). Чтобы получить более специфическое поведение, и выполнять проверку типов, наследуем базовый фрейм и определяем нужный нам набор классов:

```py
## атомарные типы
class Primitive(Object): pass
```

```py
class Float(Primitive):
    def __init__(self, V):
        super().__init__(float(V))
```

```py
class Int(Primitive):
    def __init__(self, V):
        super().__init__(int(V))
```

```py
## символ: имя само по себе или в коде (переменных, функций,..)
class Symbol(Primitive): pass
```

```py
## строка (заморачиваться с отдельными буквами нет смысла)
class String(Primitive): pass
```

```py
## исполняемая структура данных (c)
class Active(Object): pass
```

```py
## оператор
class Op(Active): pass

class Div(Op): pass
```

```py
## виртуальная Форт-машина
class VM(Active): pass

## команда виртуальной машины
class Cmd(Active): pass
```

```py
## функция
class Fn(Active): pass
```
